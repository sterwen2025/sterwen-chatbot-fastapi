┌─────────────────────────────────────────────────────────────────────────────┐
│                         CHATBOT LOGIC FLOW                                   │
│                    (Conditional Branches & Decision Points)                  │
│                          ** VERIFIED AGAINST CODE **                         │
└─────────────────────────────────────────────────────────────────────────────┘

START: User submits question
│
├─► Receive Request with:
│   • question: string
│   • data_sources: ["Meeting Notes", "Factsheet", "Web Search"]
│   • start_date, end_date: optional filters (YYYY-MM-DD format)
│   • selected_funds: optional list of fund names
│   • conversation_history: optional array of previous exchanges
│
▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 1: Initialize Context                                                  │
│ context = "Available Data Sources:\n\n"                                     │
│ use_google_search = False                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ DECISION POINT 1: Check if "Meeting Notes" in data_sources                  │
└─────────────────────────────────────────────────────────────────────────────┘
│
├─► YES: "Meeting Notes" selected
│   │
│   ├─► STEP 2A: RAG PIPELINE EXECUTION
│   │   │
│   │   ├─► STEP 2A-1: Generate embedding for question
│   │   │   • Call: embedding_service.generate_embedding(question)
│   │   │   • Task type: "RETRIEVAL_QUERY"
│   │   │   • Uses: Gemini embedding model
│   │   │   • Returns: 768-dimensional vector (query_embedding)
│   │   │
│   │   ├─► STEP 2A-2: Build filter criteria (BEFORE vector search)
│   │   │   • Create cosmos_filter = {} dictionary
│   │   │   │
│   │   │   ├─► DECISION POINT 1A: Date filters provided?
│   │   │   │   │
│   │   │   │   ├─► YES: start_date AND end_date both provided
│   │   │   │   │   └─► Add to cosmos_filter:
│   │   │   │   │       {"meeting_date": {"$gte": start_date, "$lte": end_date}}
│   │   │   │   │
│   │   │   │   └─► NO: start_date OR end_date missing
│   │   │   │       └─► No date constraint added to filter
│   │   │   │
│   │   │   ├─► DECISION POINT 1B: Fund filters provided?
│   │   │   │   │
│   │   │   │   ├─► YES: selected_funds list provided AND not empty
│   │   │   │   │   └─► Add to cosmos_filter:
│   │   │   │   │       {"fund_name": {"$in": selected_funds}}
│   │   │   │   │
│   │   │   │   └─► NO: selected_funds empty or null
│   │   │   │       └─► No fund constraint added to filter
│   │   │
│   │   ├─► STEP 2A-3: Perform FILTERED vector search in MongoDB
│   │   │   • Database: "Meetings"
│   │   │   • Collection: "MeetingChunks"
│   │   │   • Build pipeline with $search stage:
│   │   │     {
│   │   │       "$search": {
│   │   │         "cosmosSearch": {
│   │   │           "vector": query_embedding,
│   │   │           "path": "embedding",
│   │   │           "k": 100,                    ← Retrieve top 100 chunks
│   │   │           "filter": cosmos_filter,     ← Pre-filter BEFORE vector search
│   │   │           "exact": True                ← ENN (Exact Nearest Neighbor)
│   │   │         },
│   │   │         "returnStoredSource": True
│   │   │       }
│   │   │     }
│   │   │   • Vector search operates ONLY on pre-filtered document subset
│   │   │   • Cosine similarity on embedding field
│   │   │   • ENN used for filtered searches (50% faster per MS docs)
│   │   │
│   │   ├─► DECISION POINT 1C: Did we find any chunks?
│   │   │   │
│   │   │   ├─► YES: rag_chunks.length > 0
│   │   │   │   │
│   │   │   │   └─► Format and add to context:
│   │   │   │       context += "=== MEETING NOTES (RAG Retrieved) ===\n\n"
│   │   │   │       For each chunk in rag_chunks:
│   │   │   │         • Date: meeting_date (YYYY-MM-DD format)
│   │   │   │         • Fund: fund_name
│   │   │   │         • Manager: manager
│   │   │   │         • Chunk Type: chunk_type
│   │   │   │         • Content: text
│   │   │   │         • Relevance Score: score (formatted to 4 decimals)
│   │   │   │         • Separator: "\n---\n\n"
│   │   │   │
│   │   │   └─► NO: rag_chunks.length == 0
│   │   │       └─► Log: "No RAG chunks found"
│   │   │           context remains unchanged (no meeting notes added)
│   │
│   └─► Yield STATUS event to frontend (True during search, False when complete)
│
└─► NO: "Meeting Notes" not selected
    └─► Skip RAG pipeline entirely
        Yield STATUS=False event

▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ DECISION POINT 2: Check if "Factsheet" in data_sources                      │
└─────────────────────────────────────────────────────────────────────────────┘
│
├─► YES: "Factsheet" selected
│   │
│   ├─► STEP 3A: FACTSHEET QUERY EXECUTION
│   │   │
│   │   ├─► Call fetch_factsheets() function with parameters:
│   │   │   • start_date: start_date (optional)
│   │   │   • end_date: end_date (optional)
│   │   │   • selected_funds: selected_funds (optional)
│   │   │   • limit: 20 documents                    ← Maximum 20 factsheets
│   │   │
│   │   ├─► Query MongoDB factsheet collection:
│   │   │   • Database: "meeting_notes"
│   │   │   • Collection: "factsheet"
│   │   │
│   │   ├─► Build query filter:
│   │   │   │
│   │   │   ├─► DECISION POINT 2A: Date filters provided?
│   │   │   │   │
│   │   │   │   ├─► YES: start_date AND end_date provided
│   │   │   │   │   └─► Add to query: {"date": {"$gte": start_date, "$lte": end_date}}
│   │   │   │   │
│   │   │   │   └─► NO: No date filter applied
│   │   │   │
│   │   │   ├─► DECISION POINT 2B: Fund filters provided?
│   │   │   │   │
│   │   │   │   ├─► YES: selected_funds list provided and not empty
│   │   │   │   │   └─► Add to query: {"fund_name": {"$in": selected_funds}}
│   │   │   │   │
│   │   │   │   └─► NO: No fund filter applied
│   │   │
│   │   ├─► Execute query with:
│   │   │   • Sort: date descending (newest first)
│   │   │   • Limit: 20 documents
│   │   │
│   │   ├─► DECISION POINT 2C: Did we find any factsheets?
│   │   │   │
│   │   │   ├─► YES: factsheets.length > 0
│   │   │   │   │
│   │   │   │   └─► Format and add to context:
│   │   │   │       Call format_factsheets_for_context(factsheets)
│   │   │   │       context += formatted factsheet data
│   │   │   │       Each factsheet includes:
│   │   │   │         • Date: date field
│   │   │   │         • Fund: fund_name
│   │   │   │         • Content: factsheet_content
│   │   │   │
│   │   │   └─► NO: factsheets.length == 0
│   │   │       └─► Log: "[FACTSHEET] No factsheets found"
│   │   │           context remains unchanged
│   │
│   └─► Continue to next step
│
└─► NO: "Factsheet" not selected
    └─► Skip factsheet query entirely

▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ DECISION POINT 3: Check if "Web Search" in data_sources                     │
└─────────────────────────────────────────────────────────────────────────────┘
│
├─► YES: "Web Search" selected
│   │
│   ├─► STEP 4A: SET WEB SEARCH FLAG
│   │   │
│   │   └─► use_google_search = True
│   │       Log: "[WEB SEARCH] Google Search Grounding enabled"
│   │
│   └─► Add context-aware web search instructions to prompt:
│       │
│       └─► Instructions include (lines 1116-1133):
│           • FIRST: Read and analyze ALL internal data (RAG + Factsheet)
│           • THEN: Extract entities (funds, managers, companies)
│           • Search for SPECIFIC entities mentioned in internal data
│           • Example: Search "Cooper Square fund" NOT just "Cooper"
│           • CITATION REQUIREMENTS:
│             - Cite EVERY point with specific sources
│             - Format: "Meeting with John Doe, Sept 15, 2025"
│             - Use inline citations throughout
│           • TWO-SECTION RESPONSE STRUCTURE:
│             - **Section 1**: Internal Data Analysis (with inline citations)
│             - **Section 2**: Web Search Results (with titles and URLs)
│             - Include both analysis AND sources in web section
│
└─► NO: "Web Search" not selected
    │
    └─► use_google_search = False
        │
        └─► Add instructions:
            "3. Only use the internal data provided below. Web search is not enabled."

▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 5: BUILD FULL PROMPT                                                   │
└─────────────────────────────────────────────────────────────────────────────┘
│
├─► full_prompt = ""  (initialize empty string)
│
├─► DECISION POINT 4: Check if conversation_history exists and not empty
│   │
│   ├─► YES: conversation_history is not null AND length > 0
│   │   │
│   │   └─► Add conversation history to prompt (lines 1106-1111):
│   │       full_prompt += "Previous conversation:\n\n"
│   │       For item in conversation_history[-3:]:     ← Last 3 exchanges only
│   │         full_prompt += "User: {question}\n"
│   │         full_prompt += "Assistant: {answer}\n\n"
│   │       full_prompt += "---\n\n"
│   │
│   └─► NO: conversation_history is null or empty
│       └─► Skip conversation history section
│           Start with fresh conversation (no context from previous exchanges)
│
├─► Add current question and instructions (lines 1139-1156):
│   • Question: {question}
│   • Instructions (8 numbered points)
│   • Web search instructions (if enabled)
│   • Available data sources list
│   • Internal Data: {context} (RAG + Factsheet data)
│
▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 6: CONFIGURE GEMINI MODEL                                              │
└─────────────────────────────────────────────────────────────────────────────┘
│
├─► Import: from google.genai import types
│
├─► DECISION POINT 5: use_google_search == True?
│   │
│   ├─► YES: Web search enabled (lines 1166-1173)
│   │   │
│   │   └─► Configure Gemini with Google Search Grounding:
│   │       google_search_tool = types.Tool(google_search=types.GoogleSearch())
│   │       config = types.GenerateContentConfig(
│   │         tools=[google_search_tool],
│   │         temperature=1                    ← Maximum creativity
│   │       )
│   │       │
│   │       └─► Gemini will automatically:
│   │           1. Read internal context (RAG + Factsheet)
│   │           2. Identify entities mentioned in internal data
│   │           3. Perform web searches for those specific entities
│   │           4. Read and analyze web content
│   │           5. Synthesize internal + web data
│   │           6. Structure response in two sections
│   │
│   └─► NO: Web search disabled (lines 1174-1178)
│       │
│       └─► Configure Gemini without web search:
│           config = types.GenerateContentConfig(
│             temperature=1                    ← Maximum creativity
│           )
│           │
│           └─► Gemini will:
│               1. Read internal context only (RAG + Factsheet)
│               2. Analyze provided data
│               3. Generate response from internal data only

▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 7: CALL GEMINI STREAMING API                                           │
└─────────────────────────────────────────────────────────────────────────────┘
│
└─► Call Gemini API (lines 1181-1191):
    • Model: "gemini-3-pro-preview"
    • Method: gemini_client.models.generate_content_stream()
    • Contents: full_prompt
    • Config: config (with or without GoogleSearch tool)
    • Returns: streaming response object

▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 8: STREAM RESPONSE TO FRONTEND                                         │
└─────────────────────────────────────────────────────────────────────────────┘
│
└─► For each chunk in response (lines 1193-1212):
    │
    ├─► DECISION POINT 6: Does chunk have text attribute?
    │   │
    │   ├─► YES: hasattr(chunk, 'text') AND chunk.text is not empty
    │   │   │
    │   │   └─► Yield chunk.text to frontend via SSE
    │   │       • Backend yields text chunk
    │   │       • FastAPI StreamingResponse sends to frontend
    │   │       • Frontend receives chunk via EventSource
    │   │       • ReactMarkdown renders incrementally
    │   │
    │   └─► NO: chunk.text missing or empty
    │       │
    │       └─► Try to extract from candidates (fallback):
    │           For each candidate in chunk.candidates:
    │             For each part in candidate.content.parts:
    │               If part.text exists:
    │                 Yield part.text

▼
END: Complete response delivered to frontend


┌─────────────────────────────────────────────────────────────────────────────┐
│                        SUMMARY OF CONDITIONS                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│ WHEN RAG EXECUTES:                                                          │
│   IF "Meeting Notes" in data_sources                                        │
│     1. Generate question embedding (768-dimensional vector)                 │
│     2. Build filter criteria FIRST (before vector search):                  │
│        • Add date filter: IF start_date AND end_date provided               │
│          cosmos_filter["meeting_date"] = {"$gte": start_date, "$lte": end_date}
│        • Add fund filter: IF selected_funds provided AND not empty          │
│          cosmos_filter["fund_name"] = {"$in": selected_funds}               │
│     3. Perform FILTERED vector search in MongoDB:                           │
│        • Database: "Meetings", Collection: "MeetingChunks"                  │
│        • $search.cosmosSearch with filter parameter                         │
│        • Pre-filters documents by date and fund BEFORE vector search        │
│        • Vector search operates ONLY on filtered subset                     │
│        • Uses ENN (Exact Nearest Neighbor) for efficiency                   │
│        • k=100 (retrieve top 100 most similar chunks)                       │
│     4. Format and add to context (if chunks found)                          │
│                                                                              │
│ WHEN FACTSHEET QUERY EXECUTES:                                              │
│   IF "Factsheet" in data_sources                                            │
│     1. Call fetch_factsheets() with limit=20                                │
│     2. Build query filter:                                                  │
│        • Add date filter: IF start_date AND end_date provided               │
│        • Add fund filter: IF selected_funds provided AND not empty          │
│     3. Query MongoDB:                                                       │
│        • Database: "meeting_notes", Collection: "factsheet"                 │
│        • Sort by: date descending (newest first)                            │
│        • Limit: 20 documents maximum                                        │
│     4. Format and add to context (if factsheets found)                      │
│                                                                              │
│ WHEN WEB SEARCH EXECUTES:                                                   │
│   IF "Web Search" in data_sources                                           │
│     1. Set use_google_search = True                                         │
│     2. Add context-aware search instructions to prompt                      │
│     3. Configure Gemini with GoogleSearch tool:                             │
│        • types.Tool(google_search=types.GoogleSearch())                     │
│        • Temperature: 1.0                                                   │
│     4. Gemini automatically:                                                │
│        • Reads internal context (RAG + Factsheet)                           │
│        • Extracts entities mentioned                                        │
│        • Searches web for specific entities (not generic terms)             │
│        • Reads and analyzes web content                                     │
│        • Synthesizes internal + web data                                    │
│        • Structures response in two sections with inline citations          │
│                                                                              │
│ WHEN CONVERSATION HISTORY USED:                                             │
│   IF conversation_history exists AND length > 0                             │
│     • Include last 3 exchanges in prompt (conversation_history[-3:])        │
│     • Format: "User: {question}\nAssistant: {answer}\n\n"                   │
│     • Provides context continuity across conversation                       │
│                                                                              │
│ FILTER APPLICATION DETAILS:                                                 │
│   DATE FILTERS:                                                             │
│     • Applied when: start_date AND end_date both provided                   │
│     • Format: YYYY-MM-DD (ISO string format)                                │
│     • RAG: {"meeting_date": {"$gte": start_date, "$lte": end_date}}        │
│     • Factsheet: {"date": {"$gte": start_date, "$lte": end_date}}          │
│                                                                              │
│   FUND FILTERS:                                                             │
│     • Applied when: selected_funds list provided AND length > 0             │
│     • RAG: {"fund_name": {"$in": selected_funds}}                           │
│     • Factsheet: {"fund_name": {"$in": selected_funds}}                     │
│                                                                              │
│ KEY TECHNICAL DETAILS:                                                      │
│   • Embedding Model: Gemini (via embedding_service)                         │
│   • Embedding Dimension: 768                                                │
│   • Embedding Task Type: "RETRIEVAL_QUERY"                                  │
│   • Vector Search Method: cosmosSearch with ENN (Exact Nearest Neighbor)    │
│   • RAG Chunk Limit: 100 (top_k=100)                                        │
│   • Factsheet Limit: 20 documents                                           │
│   • LLM Model: "gemini-3-pro-preview"                                       │
│   • LLM Temperature: 1.0 (maximum creativity)                               │
│   • Response Mode: Streaming (Server-Sent Events)                           │
│   • Conversation History: Last 3 exchanges included                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
